estimatesRound[abs(estimatesCopy) >= 0.01] <- round(estimatesRound[abs(estimatesCopy) >= 0.01], decimal)
estimatesRound[abs(estimatesCopy) >= 0.01] <- sprintf(digits, estimatesCopy[abs(estimatesCopy) >= 0.01])
estimatesRound[abs(estimatesCopy) < 0.01] <- signif(estimatesCopy[abs(estimatesCopy) < 0.01], digits = 1)
# estimatesRound[abs(estimatesCopy) < 0.01] <- sprintf(pdigits, estimatesCopy[abs(estimatesCopy) < 0.01])
# fix p values
estimatesRound$p.value <- round(estimates$p.value, decimal + 2)
estimatesRound$p.value <- ifelse(estimatesRound$p.value < .001, "< .001", paste0("= ", sprintf(pdigits, estimatesRound$p.value)))
estimatesRound$p.value <- gsub("= 0.", "= .", estimatesRound$p.value)
# leave df as integers
estimatesRound$df <- round(estimates$df)
formattedOutput <- paste0("b = ", estimatesRound$estimate,
", SE = ", estimatesRound$std.error,
", z(", estimatesRound$df, ")",
" = ", estimatesRound$statistic,
", p ", estimatesRound$p.value,
", r = ", estimatesRound$es.r)
# convert hyphens to minus (only possible on UNIX systems)
if (.Platform$OS.type == 'unix') { # if linux/mac, ensure negative sign is minus, not hyphens
formattedOutput <- gsub("-", replacement = "−", formattedOutput)
}
formattedOutputDf <- data.table(term = as.character(estimates$term),
results = as.character(formattedOutput))
outputList <- list(results = formattedOutputDf)
if (showTable) {
# format table nicely
estimatesOutput <- data.frame(lapply(estimates[, -1], round, decimal + 1))
estimatesOutput <- data.table(term = as.character(estimates$term), estimatesOutput)
outputList$results2 <- estimatesOutput
}
if (showEffectSizesTable) {
# get all other effect sizes
effectSizes <- es(r = round(as.numeric(estimates$es.r), decimal + 1), decimal = decimal)
outputList$effectSizes <- data.table(term = as.character(estimates$term), effectSizes)
}
options(scipen = 0) # enable scientific notation
if (length(outputList) > 1) {
return(outputList)
} else {
return(formattedOutputDf)
}
}
reportMLM <- function(model, decimal = 2, showTable = FALSE, showEffectSizesTable = FALSE) {
# ensure significant digits with sprintf
digits <- paste0("%.", decimal, "f") # e.g, 0.10 not 0.1, 0.009, not 0.01
if (decimal <= 2) {
pdigits <- paste0("%.", 3, "f")
} else {
pdigits <- paste0("%.", decimal, "f")
}
# example output: b = −2.88, SE = 0.32, t(30) = −8.92, p < .001, r = .85
estimates <- data.frame(coef(summary(model))) # get estimates and put in dataframe
if (ncol(estimates) < 5 & (class(model)[1] == "merModLmerTest")) {
return(message("lmerTest failed to compute p values; use summary() to check; try refitting model with lme() from nlme package"))
}
effectNames <- rownames(estimates) # get names of effects
colnames(estimates) <- tolower(colnames(estimates))
colnames(estimates) <- c('estimate', 'std.error', 'df', 'statistic', 'p.value') # rename columns
estimates <- data.frame(term = effectNames, estimates, stringsAsFactors = FALSE)
rownames(estimates) <- NULL
# effect size r (Kashdan & Steger, 2006)
estimates$es.r <-  sqrt((estimates$statistic ^ 2 / (estimates$statistic ^ 2 + estimates$df))) # r
estimates$es.d <-  (2 * estimates$statistic) / sqrt(estimates$df) # d
# make a copy of estimates and convert to correct dp
estimatesCopy <- estimates[, -1]
estimatesRound <- estimatesCopy
estimatesRound[abs(estimatesCopy) >= 0.01] <- round(estimatesRound[abs(estimatesCopy) >= 0.01], decimal)
estimatesRound[abs(estimatesCopy) >= 0.01] <- sprintf(digits, estimatesCopy[abs(estimatesCopy) >= 0.01])
estimatesRound[abs(estimatesCopy) < 0.01] <- signif(estimatesCopy[abs(estimatesCopy) < 0.01], digits = 1)
# estimatesRound[abs(estimatesCopy) < 0.01] <- sprintf(pdigits, estimatesCopy[abs(estimatesCopy) < 0.01])
# fix p values
estimatesRound$p.value <- round(estimates$p.value, decimal + 2)
estimatesRound$p.value <- ifelse(estimatesRound$p.value < .001, "< .001", paste0("= ", sprintf(pdigits, estimatesRound$p.value)))
estimatesRound$p.value <- gsub("= 0.", "= .", estimatesRound$p.value)
# leave df as integers
estimatesRound$df <- round(estimates$df)
formattedOutput <- paste0("b = ", estimatesRound$estimate,
", SE = ", estimatesRound$std.error,
", t(", estimatesRound$df, ")",
" = ", estimatesRound$statistic,
", p ", estimatesRound$p.value,
", r = ", estimatesRound$es.r)
# convert hyphens to minus (only possible on UNIX systems)
if (.Platform$OS.type == 'unix') { # if linux/mac, ensure negative sign is minus, not hyphens
formattedOutput <- gsub("-", replacement = "−", formattedOutput)
}
formattedOutputDf <- data.table(term = as.character(estimates$term),
results = as.character(formattedOutput))
outputList <- list(results = formattedOutputDf)
if (showTable) {
# effect size semi partial R (Edwards et al., 2008)
anovaModel <- data.frame(anova(model))
colnames(anovaModel) <- tolower(colnames(anovaModel))
Fs <- anovaModel$f.value # F-values for each effect (marginal = type 3 SS with Satterthwaite (requires lmerTest package))
numDF <- anovaModel$numdf #numerator DFs
denDF <- anovaModel$dendf #denominator DFs
semiPartialREffect <- (numDF / denDF * Fs) / (1 + (numDF / denDF * Fs)) # effect sizes
semiPartialREffect <- data.frame(term = rownames(anovaModel), es.partR2 = semiPartialREffect, stringsAsFactors = F)
for (i in 1:nrow(semiPartialREffect)) {
estimates$es.partR2[grepl(semiPartialREffect$term[i], estimates$term)] <- semiPartialREffect[i, "es.partR2"]
}
# piecewiseSEM (Nakagawa & Schielzeth, 2013)
rsquareds <- sem.model.fits(model)
estimates$es.R2marginal <- rsquareds$Marginal
estimates$es.R2conditional <- rsquareds$Conditional
# format table nicely
estimatesOutput <- data.frame(lapply(estimates[, -1], round, decimal + 1))
estimatesOutput <- data.table(term = as.character(estimates$term), estimatesOutput)
outputList$results2 <- estimatesOutput
}
if (showEffectSizesTable) {
# get all other effect sizes
effectSizes <- es(r = round(as.numeric(estimates$es.r), decimal + 1), decimal = decimal, msg = F)
outputList$effectSizes <- data.frame(term = as.character(estimates$term), effectSizes)
}
options(scipen = 0) # enable scientific notation
if (length(outputList) > 1) {
return(outputList)
} else {
return(formattedOutputDf)
}
}
reportTtest <- function(model, decimal = 2, showTable = FALSE, showEffectSizesTable = FALSE) {
# ensure significant digits with sprintf
digits <- paste0("%.", decimal, "f") # e.g, 0.10 not 0.1, 0.009, not 0.01
if (decimal <= 2) {
pdigits <- paste0("%.", 3, "f")
} else {
pdigits <- paste0("%.", decimal, "f")
}
# example output: t(30) = 5.82, p < .001
estimates <- data.frame(df = model$parameter,
statistic = model$statistic,
p.value = model$p.value)
rownames(estimates) <- NULL
# effect sizes
estimates$es.r <-  sqrt((estimates$statistic ^ 2 / (estimates$statistic ^ 2 + estimates$df))) # r
estimates$es.d <-  (2 * estimates$statistic) / sqrt(estimates$df) # d
# make a copy of estimates and convert to correct dp
estimatesCopy <- estimates[, -1]
estimatesRound <- estimatesCopy
estimatesRound[abs(estimatesCopy) >= 0.01] <- round(estimatesRound[abs(estimatesCopy) >= 0.01], decimal)
estimatesRound[abs(estimatesCopy) >= 0.01] <- sprintf(digits, estimatesCopy[abs(estimatesCopy) >= 0.01])
estimatesRound[abs(estimatesCopy) < 0.01] <- signif(estimatesCopy[abs(estimatesCopy) < 0.01], digits = 1)
# estimatesRound[abs(estimatesCopy) < 0.01] <- sprintf(pdigits, estimatesCopy[abs(estimatesCopy) < 0.01])
# fix p values
estimatesRound$p.value <- round(estimates$p.value, decimal + 2)
estimatesRound$p.value <- ifelse(estimatesRound$p.value < .001, "< .001", paste0("= ", sprintf(pdigits, estimatesRound$p.value)))
estimatesRound$p.value <- gsub("= 0.", "= .", estimatesRound$p.value)
# leave df as integers
estimatesRound$df <- round(estimates$df)
formattedOutput <- paste0("t(", estimatesRound$df, ")",
" = ", estimatesRound$statistic,
", p ", estimatesRound$p.value,
", r = ", estimatesRound$es.r)
# convert hyphens to minus (only possible on UNIX systems)
if (.Platform$OS.type == 'unix') { # if linux/mac, ensure negative sign is minus, not hyphens
formattedOutput <- gsub("-", replacement = "−", formattedOutput)
}
formattedOutputDf <- data.table(results = as.character(formattedOutput))
outputList <- list(results = formattedOutputDf)
if (showTable) {
# format table nicely
estimatesOutput <- data.frame(lapply(estimates, round, decimal + 1))
estimatesOutput <- data.table(term = as.character(model$data.name), estimatesOutput)
outputList$results2 <- estimatesOutput
}
if (showEffectSizesTable) {
# get all other effect sizes
effectSizes <- es(r = abs(round(as.numeric(estimates$es.r), decimal + 1)), decimal = decimal, msg = F)
outputList$effectSizes <- data.table(term = as.character(model$data.name), effectSizes)
}
options(scipen = 0) # enable scientific notation
if (length(outputList) > 1) {
return(outputList)
} else {
return(formattedOutputDf)
}
}
es <- function(d = NULL, r = NULL, R2 = NULL, f = NULL, oddsratio = NULL, logoddsratio = NULL, auc = NULL, decimal = 3, msg = TRUE) {
# Last modified by Hause Lin 22-11-17 09:51 hauselin@gmail.com
# effectsizes <- vector("list", 7) # list version
effectsizes <- data.frame(matrix(NA, nrow = length(c(d, r, R2, f, oddsratio, logoddsratio, auc)), ncol = 7)) # dataframe version
names(effectsizes) <- c("d", "r", "R2", "f", "oddsratio", "logoddsratio", "auc")
# auc calculations might be off...
if (length(c(d, r, R2, f, oddsratio, logoddsratio, auc)) < 1) {
stop("Please specify one effect size!")
}
if (is.numeric(d)) {
if (msg) {message(paste0("d: ", d, " ")) }
effectsizes$d <- d
effectsizes$f <- effectsizes$d / 2
effectsizes$r <- effectsizes$d / sqrt(effectsizes$d^2 + 4) # assumes equal sample size
effectsizes$R2 <- effectsizes$r^ 2
effectsizes$oddsratio <- exp(effectsizes$d / (sqrt(3) / pi))
effectsizes$logoddsratio <- effectsizes$d / (sqrt(3) / pi)
effectsizes$auc <- pnorm(effectsizes$d, 0, 1)
} else if (is.numeric(r)) {
if (msg) {message(paste0("r: ", r, " ")) }
effectsizes$d <- (2 * r) / (sqrt(1 - r^2))
effectsizes$r <- r
effectsizes$f <- effectsizes$d / 2
effectsizes$R2 <- effectsizes$r^ 2
effectsizes$oddsratio <- exp(effectsizes$d / (sqrt(3) / pi))
effectsizes$logoddsratio <- effectsizes$d / (sqrt(3) / pi)
effectsizes$auc <- pnorm(effectsizes$d, 0, 1)
} else if (is.numeric(f)) {
if (msg) {message(paste0("f: ", f, " ")) }
effectsizes$d <- f * 2
effectsizes$r <- effectsizes$d / sqrt(effectsizes$d^2 + 4) # assumes equal sample size
effectsizes$f <- f
effectsizes$R2 <- effectsizes$r^ 2
effectsizes$oddsratio <- exp(effectsizes$d / (sqrt(3) / pi))
effectsizes$logoddsratio <- effectsizes$d / (sqrt(3) / pi)
effectsizes$auc <- pnorm(effectsizes$d, 0, 1)
} else if (is.numeric(R2)) {
if (msg) {message(paste0("R2: ", R2, " ")) }
effectsizes$r <- sqrt(R2)
effectsizes$d <- (2 * effectsizes$r) / (sqrt(1 - effectsizes$r^2))
effectsizes$f <- effectsizes$d / 2
effectsizes$R2 <- R2
effectsizes$oddsratio <- exp(effectsizes$d / (sqrt(3) / pi))
effectsizes$logoddsratio <- effectsizes$d / (sqrt(3) / pi)
effectsizes$auc <- pnorm(effectsizes$d, 0, 1)
} else if (is.numeric(oddsratio)) {
if (msg) {message(paste0("odds ratio: ", oddsratio, " "))}
effectsizes$d <- log(oddsratio) * (sqrt(3) / pi)
effectsizes$f <- effectsizes$d / 2
effectsizes$r <- effectsizes$d / sqrt(effectsizes$d^2 + 4) # assumes equal sample size
effectsizes$R2 <- effectsizes$r^ 2
effectsizes$oddsratio <- oddsratio
effectsizes$logoddsratio <- effectsizes$d / (sqrt(3) / pi)
effectsizes$auc <- pnorm(effectsizes$d, 0, 1)
} else if (is.numeric(logoddsratio)) {
if (msg) {message(paste0("log odds ratio: ", logoddsratio, " ")) }
effectsizes$logoddsratio <- logoddsratio
effectsizes$d <- effectsizes$logoddsratio * (sqrt(3) / pi)
effectsizes$f <- effectsizes$d / 2
effectsizes$r <- effectsizes$d / sqrt(effectsizes$d^2 + 4) # assumes equal sample size
effectsizes$R2 <- effectsizes$r^ 2
effectsizes$oddsratio <- exp(effectsizes$d / (sqrt(3) / pi))
effectsizes$auc <- pnorm(effectsizes$d, 0, 1)
} else if (is.numeric(auc)) {
if (msg) {message(paste0("auc: ", auc, " ")) }
effectsizes$auc <- auc
effectsizes$d <- qnorm(auc, 0, 1)
effectsizes$f <- effectsizes$d / 2
effectsizes$r <- effectsizes$d / sqrt(effectsizes$d^2 + 4) # assumes equal sample size
effectsizes$R2 <- effectsizes$r^ 2
effectsizes$oddsratio <- exp(effectsizes$d / (sqrt(3) / pi))
effectsizes$logoddsratio <- effectsizes$d / (sqrt(3) / pi)
}
return(round(effectsizes, decimal))
}
# es(d = 0.3)
# es(d = 0.3, r = 0.2)
# es(d = c(0.3, 0.4), r = 0.2, f = 0.5)
# es(d = c(0.2, 0.3, 0.4))
# es(d = c(0.2, 0.3))$r
# es(r = 0.5)
# es(f = 0.24)
# es(R2 = 0.6)
# es(oddsratio = 1.6)
# es(logoddsratio = 1.6)
# es(auc = .99)
# es()
summaryh(model) # optional arguments
summaryh(model, decimal = 4, showTable = T, showEffectSizesTable = T) # optional arguments
model <- lmer(weight ~ Time*  Diet + (1 | Chick), data = ChickWeight)
model <- lme(weight ~ 1, random = ~1 | Chick, data = ChickWeight)
summary(model)
summaryh(model) # optional arguments
summaryh(model, decimal = 4, showTable = T, showEffectSizesTable = T) # optional arguments
model <- lmer(weight ~ 1 + (1 | Chick), data = ChickWeight)
model
summary(model)
summaryh(model) # optional arguments
summaryh(model, decimal = 4, showTable = T, showEffectSizesTable = T) # optional arguments
summaryh(t.test(mpg ~ vs, mtcars), 3, T, T)
summaryh(t.test(mpg ~ vs, mtcars))
summaryh(glm(vs ~ mpg, mtcars, family = "binomial"), 3, T, T)
summaryh(glm(vs ~ mpg, mtcars, family = "binomial"))
summaryh(glm(vs ~ mpg + cyl, mtcars, family = "binomial"), 3, T, T)
summaryh(glm(vs ~ mpg + cyl, mtcars, family = "binomial"))
summaryh(glm(vs ~ 1, mtcars, family = "binomial"), 3, T, T)
summaryh(glm(vs ~ 1, mtcars, family = "binomial"))
summaryh(cor.test(mtcars$mpg, mtcars$gear))
summaryh(cor.test(mtcars$mpg, mtcars$gear), method = "kendal")
summaryh(cor.test(mtcars$mpg, mtcars$gear), method = "kendall")
summaryh(cor.test(mtcars$mpg, mtcars$gear), method = "spearman")
summaryh(cor.test(mtcars$mpg, mtcars$gear, method = "spearman"))
summaryh(cor.test(mtcars$mpg, mtcars$gear, method = "spearman"), 3, T, T)
summaryh(cor.test(mtcars$mpg, mtcars$gear, method = "kendall"), 3, T, T)
M <- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))
dimnames(M) <- list(gender = c("F", "M"),
party = c("Democrat","Independent", "Republican"))
(Xsq <- chisq.test(M))
summaryh(Xsq)
summaryh(Xsq, 3, T, T)
summaryh(lm(mpg ~ cyl + vs, mtcars))
summaryh(lm(mpg ~ cyl + vs, mtcars), 3, T, T)
summaryh(lm(mpg ~ 1, mtcars))
summaryh(lm(mpg ~ 1, mtcars), 2, T, T)
model <- aov(mpg ~ cyl, mtcars)
summaryh(aov(mpg ~ cyl, mtcars), 3, T, T)
summaryh(aov(mpg ~ 1, mtcars), 3, T, T)
# install really useful packages
packages <- c("dplyr", "data.table")
toInstall <- packages[!(packages %in% installed.packages()[,"Package"])]
if (length(toInstall)) {
install.packages(toInstall)
} else {
library(dplyr); library(data.table)
}
rm(packages); rm(toInstall)
fit_ezddm <- function(data, reactiontime, accuracy, id = NULL, group = NULL) {
message("Reaction times must be in seconds.\nAccuracy or choice must be coded as 0 (lower bound) or 1 (upper bound).")
setDT(data) # convert to data table
# if no id variable provided, assume it's just one subject's data
if (is.null(id)) {
id <- "temporary_subject"
data[, (id) := 1]
message("id variable not provided. Assuming single-subject data.")
}
# for accurate responses (coded as 1), calculate mean RT and RT variance for each subject, each condition
ddmRt <- data[get(accuracy) == 1, .(rt = mean(get(reactiontime), na.rm = T), rtVar = var(get(reactiontime), na.rm = T)), by = c(id, group)]
# calculate accuracy for each subject, each condition
ddmAcc <- data[, .(acc = mean(get(accuracy), na.rm = T), n = .N), by = c(id, group)]
if (sum(ddmAcc[, acc] %in% c(0.5, 1)) > 0) {
n_corrected <- sum(ddmAcc[, acc] %in% c(0.5, 1))
message(paste0("Mean accuracies (n = ", n_corrected, ") that are 0.5, or 1 have been adjusted slightly for model fitting."))
ddmAcc[, acc_adjust := 0]
ddmAcc[acc %in% c(0.5, 1), acc_adjust := 1]
}
# if acc is 1, apply edge correction
ddmAcc[acc == 1, acc := edgeCorrect(n)] # edge correction
# if acc is 0 or 50, add 0.001 to acc a bit so model fitting works
ddmAcc[acc %in% c(0.5), acc := acc + 0.00001]
dataForDDM <- left_join(ddmRt, ddmAcc, by = c(id, group))
# fit ez ddm model to each subject, each condition
ddmResults <- dataForDDM[, ezddm(propCorrect = acc, rtCorrectVariance_seconds = rtVar, rtCorrectMean_seconds = rt), by = c(id, group)]
ddmResults <- left_join(ddmResults, ddmRt, by = c(id, group)) %>% left_join(ddmAcc, by = c(id, group))
# remove temporary_subject variable
if (id == 'temporary_subject') {
ddmResults[, temporary_subject := NULL]
}
setDT(ddmResults) # ensure it's data table format
setnames(ddmResults, c("v", "a", "Ter", "rt", "rtVar"), c("drift_v", "threshold_a", "ndt_Ter", "rt_acc1", "rtVar_acc1"))
return(ddmResults[])
}
ezddm <- function(propCorrect, rtCorrectVariance_seconds, rtCorrectMean_seconds, nTrials = NULL) {
#'  propCorrect: proportion correct (apply edge correction if necessary)
#'  rtVariance: variance of correct reaction times (in seconds)
#'  rtMean: mean of correct reaction times (in seconds)
#'  nTrials (optional): number of trials (useful for edge correction)
s <- 0.1 # s is scaling parameter (defaults to 0.1 in Ratcliff's models)
s2 <- s^2 # variance
v <- as.numeric(NA)
a <- as.numeric(NA)
Ter <- as.numeric(NA)
# if propCorrect equals 0, 0.5, or 1, this method will not work, and an edge correction is required
if (propCorrect %in% c(0, 0.5, 1)) {
if (propCorrect == 0) {
return(cat("Oops, propCorrect == 0. Can't fit model! D:"))
} else if (propCorrect == 0.5) {
cat("Oops, propCorrect == 0.5 (chance performance; drift will be close to 0). Added 0.00001 to propCorrect.\n")
propCorrect <- propCorrect + 0.00001
} else if (propCorrect == 1) {
if (!is.null(nTrials)) {
cat("Oops, propCorrect == 1. Applied edge correction.\n")
propCorrect <- 1 - (1 / (2 * nTrials))
} else {
cat("Oops, propCorrect == 1. Edge correction required. Provide number of trials (nTrials).\n")
}
}
}
if (propCorrect != 1) {
L <- qlogis(propCorrect) # calculates logit
x <- L * (L * propCorrect^2 - L * propCorrect + propCorrect - 0.5) / rtCorrectVariance_seconds
v <- sign(propCorrect - 0.5) * s * x^(1/4) # drift rate
a <- s2 * qlogis(propCorrect)/v # threshold
y <- -v*a/s2
MDT <- (a/(2*v)) * (1-exp(y))/(1 + exp(y))
Ter <- rtCorrectMean_seconds - MDT # non-decision time
}
return(data.frame(v, a, Ter))
}
edgeCorrect <- function(n) {
#' n: number of observations
return(1 - (1 / (2 * n)))
}
# test function
# ezddm(.802, .112, .723)
# ezddm(.5, .112, .723)
# ezddm(.51, .112, .723)
# ezddm(0, .112, .723)
# ezddm(0.0001, .112, .723)
# ezddm(0, .112, .723)
# ezddm(0.005, .112, .723)
# ezddm(0.005, .112, .723)
# ezddm(1, .112, .723, 100)
# ezddm(0.8881988, 0.1005484, 0.9010186)
# library(EZ2)
# Data2EZ(.802, .112, .723)
# Data2EZ(.5, .112, .723)
# Data2EZ(0.8881988, 0.1005484, 0.9010186)
# Data2EZ(0.1, 0.1005484, 0.9010186)
# Data2EZ(0.00001, 0.1005484, 0.9010186)
# ezddm(0.000001, 0.1005484, 0.9010186)
# ezddm(0.00001, 0.1005484, 0.9010186)
# ezddm(0.5, 0.1005484, 0.9010186)
# ezddm(0.51, 0.1005484, 0.9010186)
# data.frame(Data2EZ(.802, .112, .723))
# library(rtdists)
# rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
# rt1 <- rdiffusion(200, a=1, v=2, t0=0.5) # default s = 1
# summary(rt1)
# rt1$response <- rep(c(0, 1), each = 100)
# fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
rt1 <- rdiffusion(200, a=1, v=2, t0=0.5) # default s = 1
summary(rt1)
rt1$response <- rep(c(0, 1), each = 100)
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
library(rtdists)
rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
summary(rt1)
rt1$response <- rep(c(0, 1), each = 100)
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
rt1 <- rdiffusion(200, a=1, v=2, t0=0.5) # default s = 1
summary(rt1)
rt1$response <- rep(c(0, 1), each = 100)
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
rt1
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
rt1$response <- rep(c(0, 1), each = 100)
rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
summary(rt1)
rt1$response <- rep(c(0, 1), each = 100)
rt1 <- rdiffusion(200, a=0.2, v=0.02, t0=0.5, s=0.1); rt1$response <- ifelse(rt1$response == "upper", 1, 0)
rt1
fit_ezddm(data = rt1, reactiontime = "rt", accuracy = "response")
setDT(data) # convert to data table
data = rt1
rt1
setDT(data) # convert to data table
id = NULL
group = NULL
reactiontime = 'rt'
accuracy = 'response'
# if no id variable provided, assume it's just one subject's data
if (is.null(id)) {
id <- "temporary_subject"
data[, (id) := 1]
message("id variable not provided. Assuming single-subject data.")
}
data
data
data[get(accuracy) == 1, .(rt = mean(get(reactiontime), na.rm = T), rtVar = var(get(reactiontime), na.rm = T)), by = c(id, group)]
ddmRt <- data[get(accuracy) == 1, .(rt = mean(get(reactiontime), na.rm = T), rtVar = var(get(reactiontime), na.rm = T)), by = c(id, group)]
ddmRt
ddmAcc <- data[, .(acc = mean(get(accuracy), na.rm = T), n = .N), by = c(id, group)]
ddmAcc
if (sum(ddmAcc[, acc] %in% c(0.5, 1)) > 0) {
n_corrected <- sum(ddmAcc[, acc] %in% c(0.5, 1))
message(paste0("Mean accuracies (n = ", n_corrected, ") that are 0.5, or 1 have been adjusted slightly for model fitting."))
ddmAcc[, acc_adjust := 0]
ddmAcc[acc %in% c(0.5, 1), acc_adjust := 1]
}
# if acc is 1, apply edge correction
ddmAcc[acc == 1, acc := edgeCorrect(n)] # edge correction
# if acc is 0 or 50, add 0.001 to acc a bit so model fitting works
ddmAcc[acc %in% c(0.5), acc := acc + 0.00001]
dataForDDM <- left_join(ddmRt, ddmAcc, by = c(id, group))
dataForDDM
# fit ez ddm model to each subject, each condition
ddmResults <- dataForDDM[, ezddm(propCorrect = acc, rtCorrectVariance_seconds = rtVar, rtCorrectMean_seconds = rt), by = c(id, group)]
dataForDDM
c(id, group)
dataForDDM
c(id, group)
dataForDDM
set(dataForDDM)
setDT(dataForDDM)
dataForDDM[, ezddm(propCorrect = acc, rtCorrectVariance_seconds = rtVar, rtCorrectMean_seconds = rt), by = c(id, group)]
ddmResults <- dataForDDM[, ezddm(propCorrect = acc, rtCorrectVariance_seconds = rtVar, rtCorrectMean_seconds = rt), by = c(id, group)]
ddmResults
ddmResults <- left_join(ddmResults, ddmRt, by = c(id, group)) %>% left_join(ddmAcc, by = c(id, group))
ddmResults
# remove temporary_subject variable
if (id == 'temporary_subject') {
ddmResults[, temporary_subject := NULL]
}
id
id == 'temporary_subject'
ddmResults
if (id == 'temporary_subject') {
ddmResults[, temporary_subject := NULL]
}
ddmResults
ddmResults
# remove temporary_subject variable
if (id == 'temporary_subject') {
ddmResults$temporary_subject <- NULL
}
setDT(ddmResults) # ensure it's data table format
ddmResults
setnames(ddmResults, c("v", "a", "Ter", "rt", "rtVar"), c("drift_v", "threshold_a", "ndt_Ter", "rt_acc1", "rtVar_acc1"))
ddmResults[]
